# 소프트웨어 설계
***

### 소프트웨어 생명주기
* 개발 방법론 바탕
* 개발 단계와 주요 활동, 결과에 대한 산출물로 표현
* 소프트웨어 품질이 유지되도록 지속적으로 검증해야함
* 개발 관련 사항 및 결과에 대한 명확한 기록 유지
* 현대적인 프로그래밍 기술을 계속적으로 적용

### 폭포수모형(Waterfall Model)
* 소프트웨어 공학에서 가장 오래되고 가장 폭넓게 사용된 전통적인 `소프트웨어 생명 주기 모형`
* 개발 과정의 단계가 끝나야만 다음 단계로 넘어갈 수 있는 선형 순차적 모형
* 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야함

### 나선형 모형(Sprial Model, 점진적 모형)
* 보헴(Boehm)이 제안
* 폭포수모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
* 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적
* 개발 과정이 반복되므로 누락되거나 추가된 요구사항 첨가 가능. 정밀하며 유지보수 과정이 필요 없음

### 애자일(Agile)
* 고객의 요구사항 변화에 유연하게 대응
* 프로세스와 도구보다는 `개인과 상호작용`에 더 가치를 둠
* 문서보다는 `SW`에 가치를 둠
* 계약 협상보다는 `고객과 협업`
* 계획을 따르는 것보다 `변화에 반응`

### 스크럼
* 팀이 중심이 되어 개발의 효율성을 높임
* 팀원 스스로 팀을 구성해야하며, 개발 작업에 관한 모든 것을 스스로 해결
    * 제품 책임자 : 이해도가 높으며, 요구사항을 책임지고 의사결정하는 사람. 개발 의뢰자 or 사용자
    * 스크럼 마스터 : 객관적 시각에서 조언하는 가이드. 통제하는 것이 목표x
    * 개발팀 : 보통 최대 인원은 7-8명이 적당

### XP(eXtreme Programming)
* 짧고 반복적인 개발 주기, 단순 설계, 고객의 적극적인 참여를 통해 빠르게 설계하는 목적
* 5가지 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백
   * Pair Programming(짝 프로그래밍) : 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 공동책임을 나눔
   * Collective Ownership(공동 코드 소유) : 개발 코드에 대한 권한과 책임을 공동으로 소유
   * Test-Driven Development(테스트 주도 개발)
   * Whole Team
   * Continuous Integration(계속적인 통합)
   * Design Improvement or Refactoring(디자인 개선 또는 리팩토링)
   * Small Releases

### 운영체제(OS)
* 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어
* 요구사항 식별 시 고려사항
   * 가용성
   * 성능
   * 기술 지원
   * 주변 기기
   * 구축 비용

### 데이터베이스 관리 시스템(DBMS)
* 데이터베이스의 구성, 접근 방법, 유지관리에 대한 모든 책임을 가지며, 데이터베이스를 관리해주는 SW
* 요구사항 식별 시 고려사항
   * 가용성
   * 성능
   * 기술 지원
   * 상호 호환성
   * 구축 비용

### 요구사항 개발 프로세스
* 도출 - 분석 - 명세 - 확인

### 자료 흐름도(DFD)
* 요구사항 분석에서 자료의 흐름과 처리 과정을 도형 중심으로 기술
* 버블 차트
   * `프로세스(Process)` 'ㅇ'
   * `자료 흐름(Data Flow)` '->'
   * `자료 저장소(Data Store)` '='
   * `단말(Teminator)` 'ㅁ'

### HIPO(Hierarchy Input Process Output)
* 시스템 실행의 입력, 처리, 출력의 기능을 나타냄
* `하향식 소프트웨어` 개발을 위한 문서화 도구
   * 가시적 도표 : 전체적 기능과 흐름을 보여주는 tree 구조
   * 총체적 도표 : 프로그램을 구성하는 전반적인 정보를 제공
   * 세부적 도표 : 기본 요소들을 기술

### UML(Unified Modeling Language)
* 개발 과정에서 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 객체지향 모델링 언어
* 구성요소
   * `사물(Things)`
   * `관계(Relationships)`
   * `다이어그램(Diagram)`

### 다이어그램(Diagram)
* 구조적 다이어그램
   * `클래스` 다이어그램 : 구조 파악, 구조상 문제점 도출
   * `객체` 다이어그램 : 럼바우 객체지향 분석 기법에서 객체 모델링 활용
   * 컴포넌트 다이어그램
   * 배치 다이어그램
   * 복합체 구조 다이어그램
   * 패키지 다이어그램

* 행위 다이어그램
   * `유스케이스` 다이어그램 : 사용자의 요구 분석하는 기능 모델링 작업
   * `시퀀스` 다이어그램 : 시스템이나 객체들이 주고 받는 메세지 표현
   * 커뮤니티케이션 다이어그램
   * `상태` 다이어그램 : 럼바우 객체지향 분석 기법에서 동적 모델링 활용
   * `활동` 다이어그램 : 처리 흐름을 순서에 따라 표현
   * 상호작용 개요 다이어그램
   * 타이밍 다이어그램

### 시퀀스 다이어그램
* 액터 : 서비스를 요청하는 외부요소. 사람 or 외부 시스템
* 객체 : 메세지를 주고받는 주체
* 생명선 : 객체가 메모리에 존재하는 기간
* 실행 상자 : 메세지를 주고받으며 구동되고 있음을 표현
* 메세지 : 객체가 상호작용을 위해 주고받는 메세지

### UI설계 원칙
* 직관성 : 누구나 쉽게 이해하고 사용
* 유효성 : 목적달성
* 학습성 : 쉽게 배움
* 유연성 : 요구사항 최대 수용. 실수 최소화

### UI 설계 도구
* 와이어프레임 : 기획단계 초기 제작. 뼈대를 설계
* 목업 : 실제 화면보다 유사하게 만든 정적인 모형
* 스토리보드 : 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름을 추가한 문서
* 프로토타입 : 실제 구현한 것처럼 테스트가능. 서비스 이해를 위한 샘플
* 유스케이스 : 사용자측 요구사항을 문서화

### 소프트웨어 품질 요구사항
* ISO/IEC 9126 : `국제표준`
   * 기능성
   * 신뢰성
   * 사용성
   * 효율성
   * 유지보수성
   * 이식성
* ISO/IEC 25010 : 2011년 개정된 국제표준
* ISO/IEC 12119 : 9126을 준수한 품질 표준으로 테스트절차를 포함하여 준수
* ISO/IEC 14598 : 개발자,구매자,평가자 별로 수행할 제품 평가 활동을 규정

### HCI(Human Computer Interface)
* 사람이 시스템을 편리하고 안전하게 사용할 수 있도록 연구

### UX(User Experience)
* 사용자가 시스템을 이용하면서 느끼는 경험

### 감성공학
* 인간의 삶을 편리하고 안전하며 쾌적하게 만드는 것

### 객체(Object)
* 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 SW 모듈
* 일정한 기억장소를 가지고 있음
* 객체가 반응할 수 있는 메세지의 집합을 행위라고 하며, 객체는 행위의 특징을 나타냄
* 객체와 객체는 상호 연관성에 의한 관계
* 객체가 가질 수 있는 조건을 상태라고 하는데 일반적으로 상태는 시간에 따라 변함

### 클래스(Class)
* 객체의 집합.
* 객체지향 프로그램에서 데이터를 추상화하는 단위
* 클래스에 속한 각각의 객체를 인스턴스라 하며 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화라고 함

### 객체지향 분석 방법론
* `럼바우` : `객체`, `동적`, `기능` 모델로 나누어 수행
* 부치 : 미시적, 거시적 프로세스 모두 사용
* jacobson : UseCase강조
* `Coad와 Yourdon` : `E-R다이어그램` 사용


### 결합도
* `결합도가 낮으면 품질이 높다.`
* 결합도가 높으면 품질이 낮다.

### 응집도
* `응집도가 강하면 품질이 높다.`
* 응집도가 약하면 품질이 낮다.
   * 기능적 (높다)
   * 순차적
   * 교환적
   * 절차적
   * 시간적
   * 논리적
   * 우연적 (낮다)

### N-S차트
* 박스 다이어그램, Chapin Chart라고도 함
* GOTO나 `화살포 사용X`
* `시각적`으로 표현
* 읽기는 쉬우나 `작성하기 어려우며` 임의로 제어를 전이하는것이 불가능
* 총체적 구조 표현과 인터페이스 나타내기 어려움
* 단일 입구와 단일 출구

### 디자인패턴
* `범용적`인 코딩 스타일
* 객체지향 설계 및 구현의 생산성을 높이는데 적합
* 재사용을 통해 개발 시간과 비용 절약
* 개발자 간의 원활한 의사소통 가능
* 변경에 대한 유연한 대처 가능
* `초기 투자 비용 부담`
* `객체지향이 아닌 다른 기반에는 적합하지 않음`

#### - 생성패턴
* 추상팩토리
* 빌더
* 팩토리 메소드
* 프로토타입
* 싱글톤

#### - 구조패턴
* 어뎁터
* 브리지
* 컴포지트
* 데코레이터
* 퍼싸드
* 플라이웨이트
* 프록시

#### - 행위패턴
* 책임 연쇄
* 커맨드
* 인터프리터
* 반복자
* 중재주
* 메멘토
* 옵서버
* 상태
* 전략
* 템플릿 메소드
* 방문자

#### 요구사항 검증
* 동료검토 : `동료`들이 결함을 발견
* 워크스루 : `회의 전` 검토하여 회의를 통하여 결함 발견
* 인스펙션 : 작성자를 제외한 다른 `전문가`들이 결함을 발견

#### 미들웨어
* 운영체제와 응용 프로그램, 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 SW